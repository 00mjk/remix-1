{
  "version": 3,
  "sources": ["empty-module:~/utils/backend.server", "browser-route-module:/Users/kentcdodds/Desktop/locker/remix-infinite-scroll/app/routes/index.tsx?browser", "../../../app/routes/index.tsx", "../../../node_modules/react-virtual/node_modules/@reach/observe-rect/dist/observe-rect.esm.js", "../../../node_modules/react-virtual/src/useIsomorphicLayoutEffect.js", "../../../node_modules/react-virtual/src/useRect.js", "../../../node_modules/react-virtual/src/index.js"],
  "sourcesContent": ["module.exports = {};", "export { default, links } from \"/Users/kentcdodds/Desktop/locker/remix-infinite-scroll/app/routes/index.tsx\";", "import * as React from \"react\";\nimport { useVirtual } from \"react-virtual\";\nimport {\n  json,\n  LoaderFunction,\n  LinksFunction,\n  useLoaderData,\n  useSearchParams,\n  useTransition,\n} from \"remix\";\nimport stylesUrl from \"~/styles/index.css\";\nimport { countItems, getItems } from \"~/utils/backend.server\";\n\nexport let links: LinksFunction = () => {\n  return [{ rel: \"stylesheet\", href: stylesUrl }];\n};\n\nlet LIMIT = 200;\nlet DATA_OVERSCAN = 40;\n\nlet getStartLimit = (searchParams: URLSearchParams) => ({\n  start: Number(searchParams.get(\"start\") || \"0\"),\n  limit: Number(searchParams.get(\"limit\") || LIMIT.toString()),\n});\n\ntype LoaderData = {\n  items: Array<{ id: string; value: string }>;\n  totalItems: number;\n};\n\nexport let loader: LoaderFunction = async ({ request }) => {\n  let { start, limit } = getStartLimit(new URL(request.url).searchParams);\n  let data: LoaderData = {\n    items: await getItems({ start, limit }),\n    totalItems: await countItems(),\n  };\n  return json(data, {\n    headers: {\n      \"Cache-Control\": \"public, max-age=120\",\n    },\n  });\n};\n\nexport default function Index() {\n  let data = useLoaderData<LoaderData>();\n  let transition = useTransition();\n  let [searchParams, setSearchParams] = useSearchParams();\n\n  let { start, limit } = getStartLimit(searchParams);\n\n  let parentRef = React.useRef<HTMLDivElement>(null);\n\n  let rowVirtualizer = useVirtual({\n    size: data.totalItems,\n    parentRef,\n    estimateSize: React.useCallback(() => 35, []),\n  });\n\n  // start    lower           middle          upper      end\n  // |          |               |               |          |\n  //           .................... <-- shift middle to lower\n  //                           .................. <-- shift middle to upper\n\n  let lowerBoundary = start + DATA_OVERSCAN;\n  let upperBoundary = start + limit - DATA_OVERSCAN;\n  let middleCount = Math.ceil(limit / 2);\n  let firstVirtualItem = rowVirtualizer.virtualItems.at(0);\n  let lastVirtualItem = rowVirtualizer.virtualItems.at(-1);\n  if (!firstVirtualItem || !lastVirtualItem) {\n    throw new Error(\"this should never happen\");\n  }\n\n  let neededStart = start;\n\n  if (firstVirtualItem.index < lowerBoundary) {\n    // user is scrolling up. Move the window up\n    neededStart =\n      Math.floor((firstVirtualItem.index - middleCount) / DATA_OVERSCAN) *\n      DATA_OVERSCAN;\n  } else if (lastVirtualItem.index > upperBoundary) {\n    // user is scrolling down. Move the window down\n    neededStart =\n      Math.ceil((lastVirtualItem.index - middleCount) / DATA_OVERSCAN) *\n      DATA_OVERSCAN;\n  }\n\n  // can't go below 0\n  if (neededStart < 0) {\n    neededStart = 0;\n  }\n\n  // can't go above our data\n  if (neededStart + limit > data.totalItems) {\n    neededStart = data.totalItems - limit;\n  }\n\n  React.useEffect(() => {\n    if (neededStart !== start) {\n      setSearchParams({\n        start: String(neededStart),\n        limit: LIMIT.toString(),\n      });\n    }\n  }, [start, neededStart, setSearchParams]);\n\n  return (\n    <div>\n      <h1>Infinite Scroll</h1>\n      <div\n        ref={parentRef}\n        className=\"List\"\n        style={{\n          height: `800px`,\n          width: `100%`,\n          overflow: \"auto\",\n        }}\n      >\n        <div\n          style={{\n            height: `${rowVirtualizer.totalSize}px`,\n            width: \"100%\",\n            position: \"relative\",\n          }}\n        >\n          {rowVirtualizer.virtualItems.map((virtualRow) => {\n            let item = data.items[Math.abs(start - virtualRow.index)];\n\n            return (\n              <div\n                key={virtualRow.key}\n                className={\n                  virtualRow.index % 2 ? \"ListItemOdd\" : \"ListItemEven\"\n                }\n                style={{\n                  position: \"absolute\",\n                  top: 0,\n                  left: 0,\n                  width: \"100%\",\n                  height: `${virtualRow.size}px`,\n                  transform: `translateY(${virtualRow.start}px)`,\n                }}\n              >\n                {virtualRow.index}{\" \"}\n                {item\n                  ? item.value\n                  : transition.state === \"loading\"\n                  ? \"Loading more...\"\n                  : \"Nothing to see here...\"}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    </div>\n  );\n}\n", "var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n", "import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n", "import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(nodeRef) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, null)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect();\n      dispatch({ rect });\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect });\n    });\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (!state || state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n\n", "import React from 'react'\n\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = index => index\n\nconst defaultMeasureSize = (el, horizontal) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\nexport const defaultRangeExtractor = range => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  onScrollElement,\n  scrollOffsetFn,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n  const latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: [],\n  })\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef) || {\n    [sizeKey]: 0,\n  }\n  latestRef.current.outerSize = outerSize\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  scrollToFn = React.useCallback(\n    offset => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || 0) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const [range, setRange] = React.useState({ start: 0, end: 0 })\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n\n  const scrollOffsetFnRef = React.useRef(scrollOffsetFn)\n  scrollOffsetFnRef.current = scrollOffsetFn\n\n  const rangeTimeoutIdRef = React.useRef(null)\n\n  const cancelAsyncRange = React.useCallback(() => {\n    if (rangeTimeoutIdRef.current !== null) {\n      clearTimeout(rangeTimeoutIdRef.current)\n      rangeTimeoutIdRef.current = null\n    }\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    rangeTimeoutIdRef.current = setTimeout(() => {\n      setRange(prevRange => calculateRange(latestRef.current, prevRange))\n    })\n    return () => cancelAsyncRange()\n  }, [measurements, outerSize, cancelAsyncRange])\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setRange({ start: 0, end: 0 })\n      latestRef.current.scrollOffset = 0\n\n      return\n    }\n\n    const onScroll = event => {\n      const scrollOffset = scrollOffsetFnRef.current\n        ? scrollOffsetFnRef.current(event)\n        : element[scrollKey]\n\n      latestRef.current.scrollOffset = scrollOffset\n\n      cancelAsyncRange()\n      setRange(prevRange => calculateRange(latestRef.current, prevRange))\n    }\n\n    // Determine initially visible range\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey, cancelAsyncRange])\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems = React.useMemo(() => {\n    const indexes = rangeExtractor({\n      start: range.start,\n      end: range.end,\n      overscan,\n      size: measurements.length,\n    })\n\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache(old => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [\n    defaultScrollToFn,\n    horizontal,\n    measurements,\n    overscan,\n    range.end,\n    range.start,\n    rangeExtractor,\n  ])\n\n  const mountedRef = React.useRef()\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      if (estimateSize) setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset)\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({ measurements, outerSize, scrollOffset }, prevRange) {\n  const size = measurements.length - 1\n  const getOffset = index => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  if (prevRange.start !== start || prevRange.end !== end) {\n    return { start, end }\n  }\n\n  return prevRange\n}\n"],
  "mappings": "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",
  "names": []
}

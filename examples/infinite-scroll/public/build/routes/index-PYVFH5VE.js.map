{
  "version": 3,
  "sources": ["empty-module:~/utils/backend.server", "browser-route-module:/Users/kentcdodds/code/remix/examples/infinite-scroll/app/routes/index.tsx?browser", "../../../app/routes/index.tsx", "../../../node_modules/react-virtual/node_modules/@reach/observe-rect/dist/observe-rect.esm.js", "../../../node_modules/react-virtual/src/useIsomorphicLayoutEffect.js", "../../../node_modules/react-virtual/src/useRect.js", "../../../node_modules/react-virtual/src/index.js"],
  "sourcesContent": ["module.exports = {};", "export { default, links } from \"/Users/kentcdodds/code/remix/examples/infinite-scroll/app/routes/index.tsx\";", "import * as React from \"react\";\nimport { useVirtual } from \"react-virtual\";\nimport type { LoaderFunction, LinksFunction } from \"remix\";\nimport { useBeforeUnload } from \"remix\";\nimport { json, useLoaderData, useSearchParams, useTransition } from \"remix\";\nimport stylesUrl from \"~/styles/index.css\";\nimport { countItems, getItems } from \"~/utils/backend.server\";\n\nexport const links: LinksFunction = () => {\n  return [{ rel: \"stylesheet\", href: stylesUrl }];\n};\n\nconst LIMIT = 200;\nconst DATA_OVERSCAN = 40;\n\nconst getStartLimit = (searchParams: URLSearchParams) => ({\n  start: Number(searchParams.get(\"start\") || \"0\"),\n  limit: Number(searchParams.get(\"limit\") || LIMIT.toString())\n});\n\ntype LoaderData = {\n  items: Array<{ id: string; value: string }>;\n  totalItems: number;\n};\n\nexport const loader: LoaderFunction = async ({ request }) => {\n  const { start, limit } = getStartLimit(new URL(request.url).searchParams);\n  const data: LoaderData = {\n    items: await getItems({ start, limit }),\n    totalItems: await countItems()\n  };\n  return json(data, {\n    headers: {\n      \"Cache-Control\": \"public, max-age=120\"\n    }\n  });\n};\n\nconst useSSRLayoutEffect =\n  typeof window === \"undefined\" ? () => {} : React.useLayoutEffect;\n\nexport default function Index() {\n  const data = useLoaderData<LoaderData>();\n  const transition = useTransition();\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  const { start, limit } = getStartLimit(searchParams);\n  const [initialStart] = React.useState(() => start);\n\n  const parentRef = React.useRef<HTMLDivElement>(null);\n\n  const rowVirtualizer = useVirtual({\n    size: data.totalItems,\n    parentRef,\n    estimateSize: React.useCallback(() => 35, []),\n    initialRect: { width: 0, height: 800 }\n  });\n\n  useBeforeUnload(\n    React.useCallback(() => {\n      if (!parentRef.current) return;\n      sessionStorage.setItem(\n        \"infiniteScrollTop\",\n        parentRef.current.scrollTop.toString()\n      );\n    }, [state])\n  );\n\n  useSSRLayoutEffect(() => {\n    if (!parentRef.current) return;\n\n    parentRef.current.scrollTop = initialStart * 35;\n  }, [initialStart]);\n\n  const lowerBoundary = start + DATA_OVERSCAN;\n  const upperBoundary = start + limit - DATA_OVERSCAN;\n  const middleCount = Math.ceil(limit / 2);\n  const firstVirtualItem = rowVirtualizer.virtualItems.at(0);\n  const lastVirtualItem = rowVirtualizer.virtualItems.at(-1);\n  if (!firstVirtualItem || !lastVirtualItem) {\n    throw new Error(\"this should never happen\");\n  }\n\n  let neededStart = start;\n\n  if (firstVirtualItem.index < lowerBoundary) {\n    // user is scrolling up. Move the window up\n    neededStart =\n      Math.floor((firstVirtualItem.index - middleCount) / DATA_OVERSCAN) *\n      DATA_OVERSCAN;\n  } else if (lastVirtualItem.index > upperBoundary) {\n    // user is scrolling down. Move the window down\n    neededStart =\n      Math.ceil((lastVirtualItem.index - middleCount) / DATA_OVERSCAN) *\n      DATA_OVERSCAN;\n  }\n\n  // can't go below 0\n  if (neededStart < 0) {\n    neededStart = 0;\n  }\n\n  // can't go above our data\n  if (neededStart + limit > data.totalItems) {\n    neededStart = data.totalItems - limit;\n  }\n\n  React.useEffect(() => {\n    if (neededStart !== start) {\n      setSearchParams({\n        start: String(neededStart),\n        limit: LIMIT.toString()\n      });\n    }\n  }, [start, neededStart, setSearchParams]);\n\n  return (\n    <div>\n      <h1>Infinite Scroll</h1>\n      <div\n        ref={parentRef}\n        className=\"List\"\n        style={{\n          height: `800px`,\n          width: `100%`,\n          overflow: \"auto\"\n        }}\n      >\n        <div\n          style={{\n            height: `${rowVirtualizer.totalSize}px`,\n            width: \"100%\",\n            position: \"relative\"\n          }}\n        >\n          {rowVirtualizer.virtualItems.map(virtualRow => {\n            const item = data.items[Math.abs(start - virtualRow.index)];\n\n            return (\n              <div\n                key={virtualRow.key}\n                className={\n                  virtualRow.index % 2 ? \"ListItemOdd\" : \"ListItemEven\"\n                }\n                style={{\n                  position: \"absolute\",\n                  top: 0,\n                  left: 0,\n                  width: \"100%\",\n                  height: `${virtualRow.size}px`,\n                  transform: `translateY(${virtualRow.start}px)`\n                }}\n              >\n                {virtualRow.index}{\" \"}\n                {item\n                  ? item.value\n                  : transition.state === \"loading\"\n                  ? \"Loading more...\"\n                  : \"Nothing to see here...\"}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    </div>\n  );\n}\n", "var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n", "import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n", "import React from 'react'\nimport observeRect from '@reach/observe-rect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(\n  nodeRef,\n  initialRect = { width: 0, height: 0 }\n) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, initialRect)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect()\n      dispatch({ rect })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect })\n    })\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n", "import React from 'react'\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = index => index\n\nconst defaultMeasureSize = (el, horizontal) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\nexport const defaultRangeExtractor = range => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const useElementScroll = ({\n  parentRef,\n  horizontal,\n  useObserver,\n  initialRect,\n}) => {\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  const [element, setElement] = React.useState(parentRef.current)\n\n  useIsomorphicLayoutEffect(() => {\n    setElement(parentRef.current)\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setScrollOffset(0)\n\n      return\n    }\n\n    const onScroll = () => {\n      setScrollOffset(element[scrollKey])\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey])\n\n  const scrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const useMeasureParent = useObserver || useRect\n\n  const sizeKey = horizontal ? 'width' : 'height'\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef, initialRect)\n\n  return {\n    outerSize,\n    scrollOffset,\n    scrollToFn,\n  }\n}\n\nconst useWindowRect = (windowRef, initialRect = { width: 0, height: 0 }) => {\n  const [rect, setRect] = React.useState(initialRect)\n  const [element, setElement] = React.useState(windowRef.current)\n\n  useIsomorphicLayoutEffect(() => {\n    setElement(windowRef.current)\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return\n    }\n\n    function resizeHandler() {\n      const next = {\n        width: element.innerWidth,\n        height: element.innerHeight,\n      }\n\n      setRect(prev =>\n        prev.height !== next.height || prev.width !== next.width ? next : prev\n      )\n    }\n    resizeHandler()\n\n    element.addEventListener('resize', resizeHandler)\n\n    return () => {\n      element.removeEventListener('resize', resizeHandler)\n    }\n  }, [element])\n\n  return rect\n}\n\nexport const useWindowScroll = ({\n  windowRef,\n  parentRef,\n  horizontal,\n  useWindowObserver,\n  initialRect,\n}) => {\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  const [element, setElement] = React.useState(windowRef.current)\n\n  const parentOffsetRef = React.useRef(0)\n\n  const rectKey = horizontal ? 'left' : 'top'\n  const scrollKey = horizontal ? 'scrollX' : 'scrollY'\n\n  useIsomorphicLayoutEffect(() => {\n    setElement(windowRef.current)\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      parentOffsetRef.current = 0\n      setScrollOffset(0)\n\n      return\n    }\n\n    if (parentRef.current) {\n      parentOffsetRef.current =\n        element[scrollKey] + parentRef.current.getBoundingClientRect()[rectKey]\n    }\n\n    const onScroll = () => {\n      const offset = element[scrollKey] - parentOffsetRef.current\n      setScrollOffset(offset)\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey, rectKey, parentRef])\n\n  const scrollToFn = React.useCallback(\n    (offset, reason) => {\n      if (windowRef.current) {\n        const delta = ['ToIndex', 'SizeChanged'].includes(reason)\n          ? parentOffsetRef.current\n          : 0\n\n        windowRef.current.scrollTo({ [rectKey]: offset + delta })\n      }\n    },\n    [windowRef, rectKey]\n  )\n\n  const useMeasureParent = useWindowObserver || useWindowRect\n\n  const sizeKey = horizontal ? 'width' : 'height'\n\n  const { [sizeKey]: outerSize } = useMeasureParent(windowRef, initialRect)\n\n  return {\n    outerSize,\n    scrollOffset,\n    scrollToFn,\n  }\n}\n\nexport const useDefaultScroll = props => {\n  const { parentRef, windowRef } = props\n\n  const useWindow = windowRef !== undefined\n\n  const emptyRef = React.useRef(null)\n\n  const elementRes = useElementScroll({\n    ...props,\n    parentRef: useWindow ? emptyRef : parentRef,\n  })\n\n  const windowRes = useWindowScroll({\n    ...props,\n    windowRef: useWindow ? windowRef : emptyRef,\n  })\n\n  return useWindow ? windowRes : elementRes\n}\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  windowRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  useWindowObserver,\n  initialRect,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n  useScroll = useDefaultScroll,\n}) {\n  const latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: [],\n  })\n\n  const { outerSize, scrollOffset, scrollToFn: defaultScrollToFn } = useScroll({\n    windowRef,\n    parentRef,\n    horizontal,\n    useObserver,\n    useWindowObserver,\n    initialRect,\n  })\n\n  const scrollOffsetWithAdjustmentsRef = React.useRef(scrollOffset)\n  if (latestRef.current.scrollOffset !== scrollOffset) {\n    scrollOffsetWithAdjustmentsRef.current = scrollOffset\n  }\n\n  latestRef.current.outerSize = outerSize\n  latestRef.current.scrollOffset = scrollOffset\n\n  const scrollTo = React.useCallback(\n    (offset, reason) => {\n      const resolvedScrollToFn =\n        scrollToFn || (offset => defaultScrollToFn(offset, reason))\n\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [scrollToFn, defaultScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || 0) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const { start, end } = calculateRange(latestRef.current)\n\n  const indexes = React.useMemo(\n    () =>\n      rangeExtractor({\n        start,\n        end,\n        overscan,\n        size: measurements.length,\n      }),\n    [start, end, overscan, measurements.length, rangeExtractor]\n  )\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                const delta = measuredSize - item.size\n                scrollOffsetWithAdjustmentsRef.current += delta\n\n                defaultScrollToFn(\n                  scrollOffsetWithAdjustmentsRef.current,\n                  'SizeChanged'\n                )\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache(old => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [indexes, defaultScrollToFn, horizontal, measurements])\n\n  const mountedRef = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}, reason = 'ToOffset') => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollTo(toOffset, reason)\n      } else if (align === 'end') {\n        scrollTo(toOffset - outerSize, reason)\n      } else if (align === 'center') {\n        scrollTo(toOffset - outerSize / 2, reason)\n      }\n    },\n    [scrollTo]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest }, 'ToIndex')\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n  const size = measurements.length - 1\n  const getOffset = index => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  return { start, end }\n}\n"],
  "mappings": "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",
  "names": []
}
